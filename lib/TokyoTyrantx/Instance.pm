package TokyoTyrantx::Instance;
use strict;
use warnings;

use TokyoTyrant;
use IO::File;
use Cwd;

=head1 NAME

TokyoTyrantx::Instance - Manage a Tokyo Tyrant instance from perl 

=head1 VERSION

Version 0.01

=cut

our $VERSION = '0.01';

=head1 SYNOPSIS

    use TokyoTyrantx::Instance;

    my $ti = TokyoTyrantx::Instance->new( myname => {
            ...
        }
    );

=head1 FUNCTIONS

=head2 new( $name => $conf )

$conf is a hashref with the following possible keys: dir, bin_dir, log_dir, data_dir, pid_dir, host, port.
They are all optional:

bin_dir defaults to /usr/local/bin

dir serves as a default for some other dir_* variables.

log_dir defaults to dir or to /var/log if dir is not set.

data_dir defaults to dir or to /var/tyrant if dir is not set.

pid_dir defaults to dir or to /tmp if dir is not set

host defaults to the ttserver defaults

port defaults to the ttserver defaults

extra_options is optional and can contain a string of additional ttserver options

=cut

sub new {
    my $class = shift;
    my $name = shift or die 'name required';
    my $conf = shift || {};
    return bless {
        name => $name, 
        conf => $conf,
    }, $class;
}

=head2 bin_dir

Returns the bin directory.

=cut

sub bin_dir {
    my $self = shift;
    return $self->{conf}{bin_dir} || '/usr/local/bin';
}

=head2 bin_filename

Returns the tterver path.

=cut

sub bin_filename {
    my $self = shift;
    return Cwd::realpath( $self->bin_dir.'/ttserver' );
}

=head2 log_dir

Returns le log_dir

=cut

sub log_dir {
    my $self = shift;
    return $self->{conf}{log_dir} || $self->{conf}{dir} || '/var/log';
}

=head2 log_filename

Returns the log file path

=cut

sub log_filename {
    my $self = shift;
    return Cwd::realpath( $self->log_dir.'/'.$self->{name}.'.log' );
}

=head2 data_dir

Returns the data directory

=cut

sub data_dir { 
    my $self = shift;
    return $self->{conf}{data_dir} || $self->{conf}{dir} || '/var/tyrant';
}

=head2 data_filename

Returns the data file path

=cut

sub data_filename {
    my $self = shift;
    return 
        $self->{conf}{filename} =~ /\.tc/
        ? Cwd::realpath( $self->data_dir.'/'.$self->{conf}{filename} )
        : $self->{conf}{filename};
}

=head2 pid_dir

Return the pid directory

=cut

sub pid_dir { 
    my $self = shift;
    return $self->{conf}{pid_dir} || $self->{conf}{dir} || '/tmp';
}

=head2 pid_filename

Return the pid file path

=cut

sub pid_filename {
    my $self = shift;
    return Cwd::realpath( $self->pid_dir.'/'.$self->{name}.'.pid' );
}

=head2 start_cmd

Generates and returns the ttserver command line.

=cut

sub start_cmd {
    my $self = shift;
    my @cmd;
    push @cmd, $self->bin_filename;
    push @cmd, '-host '.$self->{conf}{host} 
        if $self->{conf}{host};
    push @cmd, '-port '.$self->{conf}{port} 
        if $self->{conf}{port};
    push @cmd, '-pid '.$self->pid_filename;
    push @cmd, '-log '.$self->log_filename;
    push @cmd, '-dmn';
    push @cmd, $self->{conf}{extra_options}
        if $self->{conf}{extra_options}; 
    push @cmd, $self->data_filename;
    return join(' ', @cmd);
}

=head2 get_pid

read the PID from the pid file

=cut

sub get_pid {
    my $self = shift;
    my $file = $self->pid_filename;
    my $fh = IO::File->new;
    $fh->open("<$file") or return;
    my $pid = <$fh>;
    $fh->close;
    chomp $pid;
    return $pid;
}

=head2 start

Run the command generated by start_cmd

=cut

sub start {
    my $self = shift;
    my $cmd = $self->start_cmd;
    print "Starting Tokyo Tyrant: $cmd\n";
    system($cmd) == 0 or die "cmd failed: $?";
    return 1;
}

=head2 stop

Sends the SIGINT signal to the process, returns the PID if successful, undef if not.

=cut

sub stop {
    my $self = shift;
    my $pid = $self->get_pid or die "can't find pid, pidfile=".$self->pid_filename;
    print "Stopping ttserver (sending SIGINT to pid=$pid)\n";
    return kill( 2, $pid) ? $pid : undef;
}

=head2 restart

Stop and Start

=cut

sub restart {
    my $self = shift;
    $self->stop;
    return $self->start;
}

=head2 reload

Sends the SIGHUP signal to the process, returns the PID if successful, undef if not.

=cut

sub reload {
    my $self = shift;
    my $pid = $self->get_pid or die "can't find pid";
    print "Reloading ttserver (sending SIGHUP to pid=$pid)\n";
    return kill( 1, $pid) ? $pid : undef;
}

=head2 status

Sends the 0 signal to the process, returns the PID if successful, undef if not.

=cut

sub status {
    my $self = shift;
    my $pid = $self->get_pid or return undef;
    print "Checking ttserver (sending 0 to pid=$pid)\n";
    return kill( 0, $pid) ? $pid : undef;
}

=head2 get_rdb

Instanciates a TokyoTyrant::RDB or a TokyoTyrant::RDBTBL.
And open the connection.
(It'll be up to you to close it with $rdb->close)

=cut

sub get_rdb {
    my $self = shift;
    my $classname = 'TokyoTyrant::';
    
    if ($self->{conf}{filename} =~ /\.tct/) {
        $classname .= 'RDBTBL';
    }
    else {
        $classname .= 'RDB';
    }
    
    my $rdb = $classname->new();
    unless ($rdb->open($self->{conf}{host}, $self->{conf}{port})) {
        my $ecode = $rdb->ecode();
        die "open error: ".$rdb->errmsg($ecode);
    }
    return $rdb;
}

=head2 get_cached_rdb

Same as get_rdb, but caches the $rdb.

=cut

sub get_cached_rdb {
    my $self = shift;
    return $self->{cache_rdb} ||= $self->get_rdb;
}

=head2 set_indices

=cut

sub set_indices {
    my $self = shift;
    return 1 unless $self->{conf}{indices};
    my $rdb = $self->get_rdb;
    for (keys %{ $self->{conf}{indices} }) {
        my $type = $self->{conf}{indices}{$_};
        $rdb->setindex($_, $rdb->$type() | $rdb->ITKEEP );
    }
    return 1;
}

=head2 opti_indices

=cut

sub opti_indices {
    my $self = shift;
    return 1 unless $self->{conf}{indices};
    my $rdb = $self->get_rdb;
    for (keys %{ $self->{conf}{indices} }) {
        my $type = $self->{conf}{indices}{$_};
        $rdb->setindex($_, $rdb->ITOPT )
            or return 0;
    }
    return 1;
}

=head1 AUTHOR

Antoine Imbert, C<< <antoine.imbert at gmail.com> >>

=head1 COPYRIGHT & LICENSE

Copyright 2009 Antoine Imbert, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;

